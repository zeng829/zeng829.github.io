标识符命名规则
1.标识符不可以是关键字 例如： int int = 10;
2.标识符是由字母、数字、下划线构成 int ab_c1=10;
3.标识符第一个字母只能是字母或下划线 int ab=10;
4.标识符是区分大小写的 
5.建议：给变量起名的时候，最好能够做到见名如意

数据类型
1.数据类型存在的意义：给变量分配合适的内存空间避免造成空间浪费
2.整型：整型变量表示的是整数类型的数据
整型的数据类型（区别在于所占用内存空间不同）
short（短整型）占用空间：两字节 取值范围：-2^15~2^15-1
int（整型） 占用空间：四字节 取值范围：-2^31~2^31-1
long（长整型）占用空间：Windows是四字节，Linux(32位)是四字节，(64位）八字节 取值范围：-2^31~2^31-1
long long（长长整型）占用空间：八字节 取值范围：-2^63~2^63-1
整型大小比较：short<int<=long<=long long

3.实型
实型的数据类型（区别在于表示的有效数字范围不同）
1.单精度float 占用空间：四字节 有效数字范围：7位有效数字
2.双精度double 占用空间：八字节 有效数字范围：15~16位有效数字
3.默认情况下输出一个小数，会显示出6位有效数字

4.字符型
作用：字符型变量用于显示单个字符
语法：char ch='a';（单引号里面只能写一个字符）
注意：1.在显示字符变量时，用单引号将字符括起来，不要用双引号
          2.单引号内只能有一个字符，不可以是字符串
          3.C和C++中字符变量只占用1个字节。
          4.字符型变量并不是吧字符本身放到内存中存储，而是将对应的ASCII编码放到存储单元

5.转义字符
作用：用于表示一些不能显示出来的ASCII字符
例子：/a、/n、/t等

6.字符串型
作用：用于表示一串字符串
C语言的字符串：char 字符串名[ ] = "字符串";
C++语言的字符串： string str = "字符串";(要加入string头文件）

7.布尔类型bool
作用：布尔数据类型代表真或假的值
bool类型只有两个值：ture--真（本质是1）false--假（本质是0）
bool类型只占用一个字节大小
bool类型只要值不是0都是真

8.数据的输入
作用：用于从键盘获取数据
关键字：cin
语法：cin>>变量；
数据的输出
作用：用于输出数据
关键字：cout
语法cout<<""<<endl;(这个格式会导致换行）
      cout<<"";（这个格式不会换行)

9.运算符
作用：用于执行代码的运算
运算符类型
1.算术运算符：用于处理四则运算（+、-、*、/、%、++i、i++、i--、--i）
2.赋值运算符：用于将表达式的值赋给变量
3.比较运算符：用于表达式的比较，并返回一个真值或假值
4.逻辑运算符：用于根据表达式的值返回真值或假值

 除法运算
1.除数不能为0
2.除法运算是会把小数点后面的数去除
3.小数也能相除

取余运算
1.取余运算是基于除法运算所以除数不能为0
2.小除大余数是本身
3.两个小数不可以做取余运算
4.负数取余还是本身
5.只有整型变量可以进行取余运算

自增和自减运算
1.前置递增：++a（让变量进行+1）
前置递增：先让变量+1，然后进行表达式运算
2.后置递增：a++（让变量进行+1）
后置递增：先进行表达式运算，后让变量+1 
3.前置递减：--a（让变量进行-1）
前置递减：先让变量-1，然后进行表达式运算
4.后置递减：a--（让变量进行-1）
后置递减：先进行表达式运算，后让变量-1

赋值运算符
a=2;  a+=2;(a=a-2); a*=2;(a=a*2); 
a/=2;(a=a/2) a%=2;(a=a%2) 

比较运算符
作用：用于表达式的比较，并返回一个真值或假值
比较符号
==:  相等于  例如：4==3   结果：0
!=:  不等于   例如：4!=3     结果：1
<：小于     例如：4<3      结果：0
>：大于     例如：4>3      结果：1
<=：小于等于 例如： 4<=3   结果：0
>=：大于等于 例如：4>=1    结果：1

逻辑运算符
作用：用于根据表达式的值返回真值或假值
逻辑运算符有以下符号：
! ：非  例如：!a  结果：如果a为假，则!a为真；如果a为真则!a为假
&& : 与  例如：  a&&b 如果a和b都为真，则结果为真，否则为假
||：或  例子：a||b 如果a和b有一个为真，则结果为真，二者都为假时，结果为假
&&技巧：同真为真，其余为假
||技巧：同假为假，其余为真

程序流程结构
顺序结构：程序按顺序执行，不发生跳转
选择结构：依据条件是否满足，有选择的执行相应功能
循环结构：依据条件是否满足，循环多次执行某段代码
 
选择结构
if语句
作用：执行满足条件的语句
if语句的三种形式
1.单行格式if语句：if（条件）{条件满足执行的语句}；
2.多行格式if语句：if（条件）{条件满足执行的语句}；else{条件不满足执行的语句}；
3.多条件的if语句：if（条件）{条件1满足执行的语句}；else if（条件）{条件2满足执行的的语句}....else{都不满足执行的语句}；
嵌套if语句：在if语句中，可以嵌套使用if语句，达到更精确的条件判断

三目运算符
作用：通过三目运算符实现简单的判断
语法：（表达式1？表达式2：表达式3）=返回的值
解释： 如果表达式1的值为真，执行表达式2，并返回表达式2的结果
           如果表达式1的值为假，执行表达式3，并返回表达式3的结果	

switch语句
作用：执行多条件分支语句
语法：swich（表达式）
{
	case 结果1：执行语句；break；
	case 结果2：执行语句；break；
	....
	default：执行语句；break；
}
注意：1.如果在执行语句后面没有加break，那就会接着执行那条case后面的case直到defalut或者到某一个case后面加了break的语句
          2.if和switch区别
	switch缺点，判断时候只能是整型或者字符型，不可以是一个区间
	switch优点，结构清晰，执行效率高	

循环结构
while循环语句
作用：满足循环条件，执行循环语句
语法：while（循环条件）{循环语句}
解释：只要循环条件的结果为真，就执行循环语句
注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环

do...while循环语句
作用：满足循环条件，执行循环语句
语法：do{循环语句}while；
注意：与while的区别在于do...while会先执行一次循环语句，再判断循环条件

for循环语句
作用：满足循环条件，执行循环语句
语法：for（起始表达式；条件表达式；末尾表达式）{循环语句；}
注意：for语句中的两个（；）不能省

嵌套循环
作用：在循环体中在嵌套一层循环，解决实际问题

跳转语句
break语句
作用：用于跳出选择结构或者循环结构
break使用的时机：
1.出现在switch条件语句中，作用是终止case并跳出switch
2.出现在循环语句中，作用是跳出当前循环语句
3.出现在嵌套循环中，跳出最近的内层循环语句
continue语句
作用：在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环
break和continue区别
break是直接退出循环，continue是直接执行下一次循环 
 goto语句
作用：可以无条件跳转语句
语法：goto 标记
解释：如果标记的名称存在，执行到goto语句时，会跳转到标记的位置

数组：相当于一个集合，里面存放了相同类型的数据元素
特点1：数组中的每个数据元素都是相同的数据类型
特点2：数据时由连续的内存位置组成的
一维数组定义方式：
1.数据类型 数组名{数组长度}；
2.数据类型 数组名[数组长度]={值1，值2...};
3.数据类型 数组名[ ]={值1，值2.....};
注意：1.数组下标是从0开始的
          2.如果在初始化数据时候，没有全部填完，会用0来填补剩余数据
 
一维数组数组名
用途：1.可以统计整个数组在内存中的长度 
            2.可以获取数组在内存中的首地址
注意：数组名是常量不能进行赋值

二维数组
简述：二维数组就是在一维数组上，多加一个维度
二维数组定义的四种方式：
1.数据类型 数组名[行数] [列数];
2.数据类型 数组名[行数] [列数]={{数据1，数据2},{数据3，数据4}}；
3.数据类型 数组名[行数] [列数]={数据1，数据2,数据3，数据4}；
4.数据类型 数组名[ ] [列数]={数据1，数据2,数据3，数据4}；
建议：以上4种定义方式，利用第二种更加直观，提高代码的可读性

二维数组数组名
1.查看二维数组所占内存空间
2.获取二维数组首地址

函数
作用：将一段经常使用的代码封装起来，减少重复代码
函数的定义
1.返回值类型 2.函数名 3.参数表列 4.函数体语句 5.return表达式

 函数调用
功能：使用定义好的函数
语法：函数名（参数）
简述：当函数调用时候，实参的值会传递给形参
值传递：就是函数调用时实参将数值传入形参
值传递时，如果形参发生改变，并不会影响实参
值传递的缺点：被调用的函数无法修改主函数的变量

函数的常见样式
1.无参无返 2.有参无返 3.无参有返 4.有参有返

函数的声明
作用：告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义
注意：函数的声明可以多次，但是函数的定义只能有一次

函数的分文件编写
作用：让代码结构更加清晰
步骤：1.创建后缀名.h的头文件 2.创建后缀名为.cpp的源文件 
          3.在头文件中写函数的声明	 4.在源文件中写函数的定义

指针
作用：可以通过指针间接访问内存
注意：1.内存编号时从0开始记录的，一般用十六进制数字表示
          2.可以利用指针变量保存地址
指针变量定义语法：数据类型* 变量名；
简记：指针就是个地址
指针在32位操作系统下：占用4个字节空间，64位下占用8个字节	

空指针野指针
空指针：指针变量指向内存中编号为0的空间
用途：初始化指针变量
注意：空指针指向的内存时不可以访问的
语法：int * p=NULL;	
野指针：指针变量指向非法的内存空间

常量指针和指针常量
常量指针：const int * p=&a；
特点：指针的指向可以修改，但是指针指向的值不可以修改
指针常量：int * const p=&a;
特点：指针的指向不可以修改，但是指针指向的值可以修改
const 既修饰指针，又修饰常量：const int * const p=&a
特点：指针的指向和指针指向的值都不能修改

指针和函数
作用：利用指针作函数参数，可以修改实参的值

结构体
概念：属于用户自定义的数据类型，允许用户存储不同的数据类型
结构体的定义和使用
语法：struct 结构体名 {结构体成员列表}；
通过结构体创建变量的方式有三种：
1.struct 结构体名 变量名
2.struct 结构体名 变量名={成员1值，成员2值....}
3.定义结构体时顺便创建变量
总结
1.定义结构体时的关键字是struct，不可以省略
2.创建结构体变量时，关键字struct可以省略
3.结构体变量利用操作符"."访问成员
4.“."是成员运算符 “->"是指向运算符
 
结构体数组
作用：将自定义的结构体放入到数组中方便维护
语法：struct 结构体名 数组名[元素个数] = {  {} ， {}，....}

结构体指针
作用：通过指针访问结构体中的成员
利用操作符->可以通过结构体指针访问结构体属性

结构体嵌套结构体
作用：结构体中的成员可以是另一个结构体
例如：每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体
语法：struct teacher
 {
int t_id; 
string t_name;
struct student 
{
int s_id;
string s_name;
}stu;
}s;
访问：s.stu.s_id就行

结构体做函数参数
作用：将结构体作为参数向函数中传递
传递方式：值传递、地址传递
总结：如果不想修改主函数中的数据，用值传递、反之用地址传递

结构体中const 使用场景
作用：用const来防止误操作
语法：和常量指针、指针常量差不多
例如：const struct student * stu

ASCII码大致由以下两部分组成：
1.ASCII非打印控制字符：ASCII表上的数字0-31分配给了控制字符，用于控制例如打印机等一些外围设备
2.ASCII打印字符：数字32-126分配给了能在键盘上找到的字符，当查看或打印文档时就会出现

sizeof关键字
作用：利用sizeof关键字可以统计数据类型占用内存大小
语法：sizeof（数据类型或者变量）

内存分区模型
内存大方向划分为4个区域
1.代码区：存放函数体的二进制代码，由操作系统进行管理的
2.全局区：存放全局变量的静态变量以及常量
3.栈区：由编译器自动分配释放，存放函数的参数值，局部变量等
4.堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收
内存四区意义：不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程

一.程序运行前
在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域
1.代码区：
（1）存放CPU执行的机器指令（二进制代码）
（2）代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可（避免空间资源浪费）
（3)  代码区是只读的，使其只读的原因使因为防止程序意外地修改了它的指令

2.全局区：
（1）全局变量和静态变量存放在此
（2）全局区还包含常量区，字符串常量和其他常量也存放在此
（3）该区域有的数据在程序结束后由操作系统释放
（4）局部变量和const修饰的局部变量（局部常量）不在全局区

二.程序运行后
栈区：由编译器自动分配释放，存放函数的参数值，局部变量等
注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放
 
堆区：由程序员分配释放，若程序员不释放，程序结束时由操作系统回收
在C++中主要利用new在堆区开辟内存

new操作符
c++中利用new操作符在堆区开辟数据
堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符delete
语法：new 数据类型
注意：利用new创建的数据，会返回该数据对应的类型的指针
释放堆区的数据可以用delete操作符
注意：释放数组要在delete后面加[ ]

引用
作用：给变量起别名
语法:数据类型 &别名 = 原名
注意：1.引用必须初始化
          2.引用在初始化后，不可以改变（方向不变，值可以变）

引用做函数参数
作用：函数传参时，可以利用引用的技术让形参修饰实参
优点：可以简化指针修改实参
总结：通过引用参数产生的效果同按地址传递是一样的，引用的语法更加清楚简单

引用做函数返回值
作用：引用是可以作为函数的返回值存在的
注意：不要返回局部变量的引用
用法：函数词作为左值

引用的本质：C++内部实现是一个指针常量

常量引用
作用：常量引用主要用来修饰形参，防止误操作
注意：在函数形参列表中，可以加const修饰形参，防止形参改变实参

函数提高
函数默认值
语法：返回值类型 函数名（参数=默认值）{ }
结论：如果我们自己传入数据，就用自己的数据，如果没有，那么就用默认值
注意：1.如果某个位置已经有了默认参数，那么从这个位置往后，从左到右都必须由默认值
          2.如果函数声明有默认参数，函数实现就不能有默认参数（声明和实现只能由一个有默认参数）

函数占位参数
语法：返回值类型 函数名 （数据类型）{ }

函数重载
作用：函数名可以相同，提高复用性
函数重载满足条件：
1.同一个作用域下
2.函数名称相同
3.函数参数类型不同或者个数不同或者顺便不同
注意：函数的返回值不可以作为函数重载的条件

类和对象
封装
封装的意义
1.将属性和行为作为一个整体，表现生活中的事物
2.将属性和行为加以权限控制
封装意义一：在设计类的时候，属性和行为写在一起，表现事物
语法：class 类名{ 访问权限：属性/行为}；

封装意义二：
类在设计时，可以把属性和行为放在不同的权限下，加以控制
访问权限有三种：
1.public 公共权限 类内可以访问，类外可以访问
2.protected 保护权限 类内可以访问，类外不可以访问
3.private 私有权限 类内可以访，类外不可以访问

对象的初始化和清理
构造函数和析构函数
对象的初始化和清理也是两个非常重要的安全问题
初始化：一个对象或者变量没有初始化状态，对其使用后果是未知
清理：使用完一个对象或者变量，没有及时清理，也会造成一定的安全问题
c++利用了构造函数和析构函数解决了这两个问题，这两个函数将会被编译器自动调用，完成对象初始化和清理的工作。
对象的初始化和清理工作是编译器强制要求我们做的事情，因此如果我们不提供构造和析构，编译器会提供编译器提供的构造函数和析构函数是空实现

构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用
析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作

构造函数语法：类名{}
注意：
1.构造函数，没有返回值也不写void
2.函数名称与类名相同
3.构造函数可以有参数，因此可以发生重载
4.程序在调用对象时候自动调用构造，无须手动调用，而且只会调用一次

析构函数语法：~类名（）{}
注意：
1.析构函数，没有返回值也不写void
2.函数名称与类名相同，在名称前面加上符号~
3.析构函数不可以有参数，因此不可以发生重载
4.程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次

构造函数的分类及调用
两种分类方式：
按参数分类：有参构造和无参构造
按类型分类：普通构造和拷贝构造
三种调用方式：
括号法、显示法、隐式转换法
class Person{
piblic:
	//无参（默认）构造函数
	Person(）{
	       cout<<"无参构造函数"<<endl;
	}
	//有参构造函数
	Person(int a){
		age =a ;
		cout<<"有参构造函数!"<<endl;
	}
	//拷贝构造函数
	Person(const Person &p){
		age =p.age;
		cout<<"拷贝构造函数"<<endl;
	}
	//析构函数
	~Person（）{
		cout<<"析构函数"<<endl;
	}
public:
 	int age;
};


//2、构造函数的调用
//调用无参构造函数
void test01(){
 	Person p;//调用无参构造函数
}


//调用有参的构造函数
void test02(){

	//2.1括号法，常用
	Person p1(10);
	//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明
	//Person p2（）；
	

	//2.2显示法
	Person p2 = Person(10);
	Person p3 = Person(p2);
	//Person(10)单独写就是匿名对象   当前执行结束之后， 马上析构
	 
	//2.3隐式转换法
	Person p4 = 10；//Person p4 = Person(10);
	Person p5 = p4；//Person p5 = Person(p4);

	//注意2：不能利用 拷贝构造函数  初始化匿名对象 编译器认为是对象声明
	//Person p5（p4）；


拷贝构造函数调用时机

c++中拷贝构造函数调用时机通常有三种情况
1.使用一个已经创建完毕的对象来初始化一个新对象
2.值传递的方式给函数参数传值
3.以值方式返回局部对象

//1.使用一个已经创建完毕的对象来初始化一个新对象
void test01()
{
	Person p1(10);
	Person p2(p1);
}//p2就是初始化的新对象
 
//2.值传递的方式给函数参数传值
void doWork(Person p)
{

}
void test02()
{
	Person p1;
	doWork(p1);
}//相当于 Person p=p1；所以调用了拷贝构造函数（这里用了隐式转换法）

//3.值方式返回局部对象
Person doWork2()
{
	Person p1;
	return p1;
}
void test03()
{
	Person p=doWork2();
}//也调用了拷贝构造函数
因为相当于先调用了doWork2()里的Person p1;的默认构造函数，然后拷贝p1再返回使得Person p=p1然后在调用p的拷贝调用函数（注意返回值的p1和没返回的p1不同，返回值是创建一个新的对象再拷贝p1进行返回）

构造函数调用规则
默认情况下，c++编译器至少给一个类添加3个函数
1.默认构造函数（无参，函数体为空）
2.默认析构函数（无参，函数体为空）
3.默认拷贝构造函数，对属性进行值拷贝

构造函数调用规则如下：
1.如果用户定义有构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造
2.如果用户定义拷贝构造函数，c++不会再提供其他构造函数

深拷贝和浅拷贝
浅拷贝：简单的赋值拷贝操作
深拷贝：在堆区重新申请空间，进行拷贝操作
浅拷贝带来的问题是堆区的内存重复释放   
总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题

初始化列表
作用：c++提供了初始化列表语法，用来初始化属性
语法：构造函数（）：属性1（值1），属性2（值2）...{}

类对象作为类成员
C++类中的成员可以是另一个类的对象，我们称该成员为对象成员
例如：
class A {}
class B
{
     A a;
}
B类中有对象A 作为成员，A为对象成员
//当其他类对象作为本类成员，构造时候先构造类对象，在构造自身，析构时先自身再其他类（析构可以用栈进出顺序来理解）

静态成员
静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员
静态成员分为：
1.静态成员变量
所有对象共享同一份数据
在编译阶段分配内存
类内声明，类外初始化
2.静态成员函数
所有对象共享同一个函数
静态成员函数只能访问静态成员变量（静态成员函数不可以访问非静态成员变量）

如果不创建对象想访问类中的变量或者函数就要用"::"双冒号表示作用域（静态变量才行）

C++对象模型和this指针
成员变量和成员函数分开存储
描述：在c++中，类内的成员变量和成员函数分开存储只有非静态成员变量才属于类的对象上

空对象占用内存空间为：1
c++编译器会给每个空对象也会分配一个字节空间，是为了区分空对象占内存的位置，所以每个空对象也应该有一个独一无二的内存地址

非静态成员变量是属于类的对象上
静态成员变量不属于类对象上
非静态成员函数不属于类的对象上
静态成员函数不属于类的对象上

this指针概念
this指针指向被调用的成员函数所属的对象（区分是哪个对象调用的）
this指针是隐含每一个非静态成员函数内的一种指针
this指针不需要定义，直接使用即可
this指针的用途：
1.当形参和成员变量同名时，可以用this指针来区分
2.在类的非静态成员函数中返回对象本身，可以使用return *this 

空指针访问成员函数
c++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针
如果用到this指针，需要加以判断保证代码的健壮性

const修饰成员函数
常函数：
1.成员函数后加const后我们称这个函数为常函数
2.常函数不可以修改成员属性
3.成员属性声明时加关键字mutable后，在常函数中依然可以修改

常对象：
1.声明对象前加const称该对象为常对象
2.常对象只能调用常函数

this指针的本质是指针常量，指针的指向是不可以修改的
const Person * const this;
在成员函数后面加const, 修饰的是this指向,让指针指向的值也不可以修改
void Person（）const
{
}
常对象只能调用常函数

友元
为什么需要：在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术
目的：让一个函数或者类访问另一个类中私有的成员
友元的关键字：friend
友元的三种实现
1.全局函数做友元
2.类做友元
3.成员函数做友元

继承中的对象模型
1.父类中所以非静态成员属性都会被子类继承下去
2.父类中私有成员属性 是被编译器隐藏了，因此访问不到，但是确实被继承下去了

运算符重载：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型
编译器给运算符起了一个通用的名称operator运算符
加号运算符重载
作用：实现两个自定义数据类型相加的运算
//1.成员函数重载+号
Person operator+(Person &p)
{
	Person temp;
	temp.m_a=this->m_a+p.m_a;
	temp.m_b=this->m_b+p.m_b;
	return temp;
}(m_a，m_b已经在Person类中定义了）
这样就能用自定义的类型做加法了 例如：Person p3=p1+p2；（p1+p2就调用了上面那个函数）
//成员函数重载本质调用：Person p3=p1.operator+(p2);

//2.全局函数重载+号
Person operator+(Person &p1, Person &p2)
{
	Person temp;
	temp.m_a=p1.m_a+p2.m_a;
	temp.m_b=p1.m_b+p2.m_b;
	return temp;
}
//全局函数重载本质调用
Person p3=operator+(p1,p2);
总结：1.成员函数重载和全局函数重载就少了个引用
          2.运算符重载也可以发生函数重载
          3.对于内置的数据类型的表达式的运算符时不可能改变的
          4.不要滥用运算符重载

左移运算符重载
作用：可以输出自定义数据类型
//利用成员函数重载 左移运算符 p.operator<<(cout) 简化版本p<<cout
//不会利用成员函数重载<<运算符，因为无法实现cout在左侧
  
//只能用全局函数重载左移运算符
ostream & operator<<(ostream &cout , Person &p)//本质  operator<<(cout ,p )
{
	cout <<p.m_a<<p.m_b;
	return cout;
}
//因为ostream下只有cout这一个对象所以要用cout做参数只能用引用
//因为返回值时cout所以函数的类型是返回值的类型ostream
//因为要一直返回一个cout所以ostream 后面还要加& 才会返回一个cout

递增运算符重载
作用：通过重载递增运算符，实现自己的整型数据


